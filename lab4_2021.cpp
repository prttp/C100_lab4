/*************************************************************
	Практическое занятие №4. Встроенные массивы.
							Простейшие алгоритмы сортировки и поиска.
							
*************************************************************/

#include <cstdlib>
#include <ctime>
#include <iostream>

#define	  stop __asm nop

int main()
//Задания, помеченные * не являются обязательными. Но выполнение их крайне желательно!!!
{
///////////////////////////////////////////////////////////////
//			Указатели (продолжение)                              
///////////////////////////////////////////////////////////////

		//Задание 1. Модификатор const. 
		//В каждом из заданий объявите указатель требуемого вида. 
		//Посредством каждого указателя попробуйте:
		//1) получить значение по адресу
		//2) записать новое значение по адресу
		//3) модифицировать указатель
//Замечания:
//1.операторы явного преобразования типа использовать не следует
//2.если компилятор не позволяет выполнить операцию, то комментируйте эту строку с пояснением


		//Задание 1a. Указатель является константой. 
	char Char = 'a';
	char* const pChar = &Char;
	char Char1 = *pChar; //ok
	*pChar = 'b'; //ok
	// pChar++; not ok
	
	stop


		//Задание 1б. Указываемое значение является константой.
	char const* pChar1 = &Char;
	Char1 = *pChar1; //ok
	// *pChar1 = 'b'; not ok
	pChar1++; // ok
	stop

// *******************************************************


		//Задание 1в. И указатель, и указываемое значение
		//являются константами. 
	char const* const pChar2 = &Char;
	Char1 = *pChar2; //ok
	//*pChar2 = 'b'; not ok
	//pChar2++; not ok

	stop

// *******************************************************


		//Задание 1г. Указатель на переменную, объявленную с
		//ключевым словом const. 
	const int nN = 1;
	//Объявите указатель и проинициализируйте его выражением - &nN	
	int const* pnN = &nN;
	stop


// *******************************************************

	//Задание 2. Явное преобразование указателя. 
	//Иногда возникает необходимость одни и те же данные интерпретировать по-разному,

	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт. 

	//Следовательно, возникает необходимость явного преобразования указателя. 

	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне

	//переменных и изменяйте пункт - Hexadecimal display !!!!!!!!!!!!!!!!!


	unsigned int nObject5=0x55667788;
	unsigned int* pnObject5=&nObject5;

	//Раскомментировав следующую строчку кода, обратите внимание на сообщение компилятора 
	//- он не считает преобразование "легальным" (безопасным)

	unsigned char* pucObject5;

	//pucObject5=static_cast<unsigned char*>(pnObject5);	//(1) invalid type conversion


	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
				//преобразование - целиком на совести программиста.
				//Его можно применять, только четко представляя себе
				//результат преобразования (2)

	//Откомментируйте (!) следующие строчки следующим образом:
	// сс=..., 	pucObject5 - изменился? 	*pucObject5=...

	char cc = *(pucObject5++);	//сс=0x88, 	pucObject5 - изменился 	*pucObject5=0x77
	cc = (*pucObject5)++;		//сс=0x77, 	pucObject5 - не изменился 	*pucObject5=0x78

	cc = ++*(pucObject5);		//сс=0x79, 	pucObject5 - не изменился 	*pucObject5=0x79
	cc = *(++pucObject5);		//сс=0x66, 	pucObject5 - изменился 	*pucObject5=0x66
	stop

///////////////////////////////////////////////////////////////
//			Встроенные массивы                               
///////////////////////////////////////////////////////////////

	//Задание 3. 
	//Имеется одномерный встроенный массив, проинициализированный при объявлении 
	//Отсортируйте массив по возрастанию значений. 
	//Используйте "пузырьковую" сортировку  
	// Правильность решения проверьте с помощью отладчика

	{
		int ar[] = { 5, 4, 7,  8, 1, 2, 6, 0, 10, 12, 77, 11,
					  6, 8, 33, 21, 1, 2, 3, 4};
		for (int i = 0; i < (sizeof(ar) / sizeof(int)); i++) {
			for (int j = 0; j < ((sizeof(ar) / sizeof(int))-1); j++) {
				if (ar[j] > ar[j + 1]) {
				int b = ar[j]; // создали дополнительную переменную
				ar[j] = ar[j + 1]; // меняем местами
				ar[j + 1] = b; // значения элементов
				}
			}
		}

	stop
	}
	
	
// *******************************************************
	//Задание 4  
	//в)Инициализация массива строковыми литералами:
	char const* strings[] = { "ABC", "DEF", "XYZ" }; //Объявите одномерный массив УКАЗАТЕЛЕЙ и проинициализируйте его СТРОКОВЫМИ литералами . 
	for (int i = 0; i < (sizeof(strings) / sizeof(char*)); i++) {
		std::cout << strings[i] << " "; // Выведите  массив на печать.
	}
	
	

// *******************************************************
	//Задание 5. 
	srand(time(0));
	const int N = 5;
	int arr[N];//a) Объявите одномерный неинициализированный массив ( размером N)
	for (int i = 0; i < N; i++) {
		arr[i] = rand() % 101 + 10;
	}
	//Задайте значения элементов с помощью генератора случайных чисел.
		
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	// int tmp= rand(); // получим случайное значение в диапазоне от 0 до RAND_MAX
    	//значение RAND_MAX задано в файле <stdlib.h>  и равно  0x7fff
	
	//если Вам требуется задать иные границы диапазона при генерации случайного числа, 
	//то это можно сделать так:
	//v1 = rand() % 100;         // v1 в диапазоне 0 - 99
	//v2 = rand() % 100 + 1;     // v2 в диапазоне 1 - 100
	//v3 = rand() % 30 + 1985;   // v3 в диапазоне 1985-2014 
	
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	//srand( time( 0 ) );
//(Подсказки в файле Алгоритмы для лабораторной работы_4. pdf)


	//б) Выведите массив на печать
	for (int i = 0; i < (sizeof(arr) / sizeof(int)); i++) {
		std::cout << arr[i] << " "; 
	}
	//в)Отсортируйте массив по убыванию значений. 
	//Используйте сортировку "выбором"
	for (int i = 0; i < ((sizeof(arr) / sizeof(int))-1); i++) {
		int min = i; // запоминаем индекс текущего элемента
		// ищем минимальный элемент чтобы поместить на место i-ого
		for (int j = i + 1; j < (sizeof(arr) / sizeof(int)); j++)  // для остальных элементов после i-ого
		{
			if (arr[j] < arr[min]) // если элемент меньше минимального,
				min = j;       // запоминаем его индекс в min
		}
		int temp = arr[i];      // меняем местами i-ый и минимальный элементы
		arr[i] = arr[min];
		arr[min] = temp;
	}
stop
	// 

	
// *******************************************************

	/*//Задание 6. 
	//Объявите встроенный одномерный массив, состоящий из N элементов целого типа. 
	
	int arr6[N];
	//Напишите фрагмент кода, который вводит целые числа с помощью
	//потока ввода в объявленный Вами массив, каждый раз ( на каждой итерации!)
	//упорядочивая полученное значение по возрастанию.
	//Для проверки выводите массив на консоль на каждой итерации`
	for (int i = 0; i < (sizeof(arr6) / sizeof(int)); i++) {
		int value;
		std::cin >> value;
		arr6[0] = value; // помещаем значение в крайнее положение
		for (int j = 0; j < ((sizeof(arr6) / sizeof(int)) - 1); j++) {
			if (arr6[j] > arr6[j + 1]) {
				int b = arr6[j]; // создали дополнительную переменную
				arr6[j] = arr6[j + 1]; // меняем местами
				arr6[j + 1] = b; // значения элементов
			}
		}
		for (int s = 0; s < (sizeof(arr6) / sizeof(int)); s++) {
			std::cout << arr6[s] << " ";
		}
	}
	stop 
// *******************************************************
	//Задание 7. 

	//Простой поиск.
	//Модифицируйте предыдущее задание следующим образом:
	//очередное введенное значение помещается в массив только при условии, 
	//что там еще такого нет (то есть дубли игнорируются)
	int arr7[N];
	for (int i = 0; i < (sizeof(arr7) / sizeof(int)); i++) {
		int value;
		std::cin >> value;
		bool flag = 0;
		for (int f = 0; f < (sizeof(arr7) / sizeof(int)); f++) {
			if (arr7[f] == value) { // проверяем совпадение
				flag = 1;
			}
		}
		if (flag == 1) {
			i--;
			std::cout << "Error! The element exists already!" << std::endl;
			continue;
		}
		arr7[0] = value;
		for (int j = 0; j < ((sizeof(arr7) / sizeof(int)) - 1); j++) {
			if (arr7[j] > arr7[j + 1]) {
				int b = arr7[j]; // создали дополнительную переменную
				arr7[j] = arr7[j + 1]; // меняем местами
				arr7[j + 1] = b; // значения элементов
			}
		}
		for (int s = 0; s < (sizeof(arr7) / sizeof(int)); s++) {
			std::cout << arr7[s] << " ";
		}
	}
	stop

// *******************************************************
	//Задание 8
	//Объявите одномерный встроенный массив элементов типа char.
	char arr8[12];
	//Сформируйте значения элементов массива с помощью генератора случайных 
	//чисел таким образом, чтобы в массиве были только символы '*' и '_'  
	char base[] = { '*', ' ' };
	for (int i = 0; i < 12; i++) {
		arr8[i] = base[rand() % 2];
	}
	stop
		//"сдвиньте звездочки" в начало массива, например:
		//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
		//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
	int left = 0;
	int right = N - 1;
	for (int i = 0; i < ((sizeof(arr8) / sizeof(char))-1) ; i++) {
			if (left < right) { 
				if (arr8[left] == ' ') {
					if (arr8[right] == '*') {
						char tmp = arr8[left];
						arr8[left] = arr8[right];
						arr8[right] = tmp;
						left++;
						right--;
					}
					else { right--; }
				}
				else { left++; }
			}
			else { break; }
		}
	//и распечатайте массив 
	for (int s = 0; s < (sizeof(arr8) / sizeof(char)); s++) {
		std::cout << arr8[s] << " ";
	}
//(Подсказки в файле Алгоритмы для лабораторной работы_4. pdf)

// *******************************************************
	*///Задание 9
	//объявите одномерный встроенный массив  из N элементов и проинициализируйте его.
	int arr9[N] = {1, 2, 3, 4, 5};
	//а) сдвиньте все элементы массива вправо на 1 позицию
	for (int i = ((sizeof(arr9) / sizeof(int)) - 1); i > 0; i--) {
		arr9[i] = arr9[i - 1];
		//arr9[i - 1] = 0;
	}
	//б) (Циклическая перестановка). Сдвиньте все элементы массива вправо на 1 позицию , 
	//но последний элемент не должен быть утерян. Его следут переместить в начало.
	//например,  { 5, 2, 11, 4, 23, 9 } ->  {9, 5, 2, 11, 4, 23 }
	int temp;
	for (int i = ((sizeof(arr9) / sizeof(int)) - 1); i > 0; i--) {
		if (i == ((sizeof(arr9) / sizeof(int)) - 1)) { temp = arr9[i]; };
		arr9[i] = arr9[i - 1];
		arr9[i - 1] = 0;
		if (i == 1) { arr9[i - 1] = temp; };
	}
	//в)(Кольцевой буфер) выведите массив на печать, циклически "сдвинув" элементы вправо на 1 позицию.
	//При решении задачи не следует перемещать элементы массива, а надо использовать кольцевой буфер.
	// Одномерный массив можно "свернуть" в кольцо и считать, что за последним элементом следует начальный и
	// потом установить "новое" начало массива.
	int gap = N-1;
	for (int i = 0; i < (sizeof(arr9) / sizeof(int)); i++) {
		int pos = (i + gap) % (sizeof(arr9) / sizeof(int));
		std::cout << arr9[pos] << ' ';
	}
	stop
// *******************************************************
	//Задание 10 (*)
	//алгоритм "тасования колоды"
	//объявите одномерный встроенный массив  из N элементов и 
	// заполните  его неповторяющимися числами из заданного отрезка 
	//натурального ряда, расположенными в случайном порядке

//(Подсказки в файле Алгоритмы для лабораторной работы_4.pdf)
//Алгоритм:
//Массив  A [N] инициализируется последовательными значениями из отрезка, например [0,N-1]
//index=N-1, где index- максимальное значение индекса.
	int A[N] = { 0, 1, 2, 3, 4 };
	int index = N - 1;
	int R;
	int tmp;
//В цикле по index выполняется перемешивание значений:
//	1. Генерируется случайное число  R из отрезка [0, index]
//	2. Выполняется обмен значений A[index]  и  A[R]
//	3. index=index -1
//	4. Если index==0, то конец
//	5. Переход к шагу 1    
	while (index != 0) {
		R = rand() % (index + 1);
		tmp = A[R];
		A[R] = A[index];
		A[index] = tmp;
		index--;
}
	stop
// *******************************************************

}
